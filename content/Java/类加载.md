
#面试 

类加载指，将描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

类加载分为**加载**、**验证**、**准备**、**解析**、**初始化**、**使用**、**卸载**这几个步骤。其中，**验证**、**准备**、**解析**这三个步骤被统称为**连接**。

## 加载

查找并加载类的二进制数据。

1. 通过一个类的 [[全限定名]] 来获取定义此类的二进制字节流；
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

## 验证

确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会为危害虚拟机的自身安全，验证阶段大致包含以下4个步骤：

1. 文件格式验证：验证字节流是否符合Class文件格式的规范。例如：是否以`0xCAFEBABE`开头，主次版本号是否在当前虚拟机的处理范围之内，常量池中的常量是否有不被支持的类型。
2. 元数据验证：对字节码描述信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。例如：这个类是否有父类。
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
4. 符号引用验证：确保解析动作能正确执行。

验证阶段不是必须的，对程序运行期没有影响。如果引用的类经过反复验证，可以考虑采用`-Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。


## 准备

为类的静态变量分配内存，并将其初始化为默认值，这些变量所使用的内存都将在方法区中被分配。

这时候进行内存分配的仅包括类变量（被static修饰的变量），实例变量会在对象实例化时随着对象一起分配在Java堆中。

这些类变量的初始值通常情况下是数据类型默认的零值，而不是在Java代码中被显式赋予的值。赋值的动作在**初始化**阶段才会执行。

## 解析

虚拟机将常量池内的 [[符号引用与直接引用#符号引用|符号引用]] 替换为 [[符号引用与直接引用#直接引用|直接引用]] 的过程。解析动作主要针对类、接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。

## 初始化

对类的静态变量，静态代码块执行初始化操作。

类初始化步骤：
- 如果这个类还没有被加载和连接（验证、准备和解析），则程序先加载并连接该类；
- 如果类的直接父类还没有被初始化，则先初始化其直接父类；
- 如果类中有初始化语句，则系统依次执行这些初始化语句。

 触发类初始化的时机：
 
 - 使用new关联字实例化变量时；
 - 读取或设置一个类型的静态字段时；
 - 调用一个类的静态方法时；
 - 使用`jvava.lang.reflect`包中的方法对类型进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化；
 - 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；
 - 当虚拟机启动时，用户需要制定一个类执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类。

以下集中情况不会执行类初始化：

- 通过子类引用父类的静态字段，只会触发父类的初始化，不会触发子类的初始化；
- 定义对象数组，不会触发该类的初始化；
- 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在类的初始化；
- 通过类名获取Class对象，不会触发类的初始化；
-  通过`Class.forName`加载制定类时，如果制定参数`initialize`为`flase`时，不会触发类初始化
- 通过`ClassLoader`默认的`loadClass`方法，也不会触发初始化动作。

类初始化步骤：

1. 初始化父类中的静态成员变量和静态代码块; 
2. 初始化子类中的静态成员变量和静态代码块；
3. **初始化父类的普通成员变量和代码块，再执行父类的构造方法；**
4. **初始化子类的普通成员变量和代码块，再执行子类的构造方法；**