
网络 I/O 模型大致可以分为同步 I/O 与异步 I/O 两类。同步 I/O 又可分出**阻塞 I/O**、**非阻塞 I/O**、**非阻塞 I/O**、**多路复用 I/O** 和**信号驱动 I/O** 四种细分模型。

## 异步 I/O

发出调用请求之后将立即返回，不会马上得到处理结果。结果将通过状态变化和回调来通知调用者。

异步模型受限于操作系统，Linux 在 Kernel 2.6 才引入异步 IO，目前也不算很完善。因此在 Linux 下实现高并发网络编程时，以使用多路复用 I/O 为主。

## 同步 I/O

同步 I/O 指在调用端发出请求之后，到得到结果之前，线程必须一直等待。

### 阻塞 I/O（Blocking I/O）

在得到结果前，线程会处于休眠状态。阻塞 I/O 逻辑清晰，也比较节省 CPU 资源，但线程休眠会带来上下文切换。

### 非阻塞 I/O（Non-Bocking I/O）

线程不休眠，每隔一段时间来查询结果，直到结果返回。非阻塞 I/O 只适合于能够快速返回的请求。

### 多路复用 I/O（Multiplexing I/O）

本质上是阻塞 I/O 的一种，只是在同一条阻塞线程上处理多个不同端口的监听。多路复用 I/O 是目前主流的网络高并发方案。其还可细分为 select 、epoll、kqueue 等不同实现。

### 信号驱动 I/O（Signal-Driven I/O）

通过信号通知结果已返回。得到返回结果后，数据先会放到操作系统内核的缓冲区里，然后从内核缓冲区复制数据到应用地址空间。信号驱动与异步的区别在于，在执行“内核缓冲区复制数据到应用程序地址空间”这一步骤时，信号驱动 I/O 会处于阻塞状态，而异步 I/O 不会阻塞。